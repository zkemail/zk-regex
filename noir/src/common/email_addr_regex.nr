use crate::utils::{
   select_subarray,
   captures::capture_substring,
   sparse_array::SparseArray,
   transitions::check_transition_with_captures
};

global TRANSITION_TABLE: SparseArray<378, Field> = SparseArray {
    keys: [0x00000000, 0x00022523, 0x00022524, 0x00022525, 0x00022725, 0x00022726, 0x00022727, 0x00022826, 0x00022827, 0x00022828, 0x00022927, 0x00022928, 0x00022929, 0x00022a28, 0x00022a29, 0x00022a2a, 0x00022b29, 0x00022b2a, 0x00022b2b, 0x00022e2c, 0x00022e2d, 0x00022e2e, 0x00022f2d, 0x00022f2e, 0x00022f2f, 0x0002312f, 0x00023130, 0x00023131, 0x00023230, 0x00023231, 0x00023232, 0x00023331, 0x00023332, 0x00023333, 0x00023432, 0x00023433, 0x00023434, 0x00023533, 0x00023534, 0x00023535, 0x00023634, 0x00023635, 0x00023636, 0x00023735, 0x00023736, 0x00023737, 0x00023836, 0x00023837, 0x00023838, 0x00023937, 0x00023938, 0x00023939, 0x00023a38, 0x00023a39, 0x00023a3a, 0x00023b39, 0x00023b3a, 0x00023b3b, 0x00023c3a, 0x00023c3b, 0x00023c3c, 0x00023d3b, 0x00023d3c, 0x00023d3d, 0x0002413f, 0x00024140, 0x00024141, 0x00024341, 0x00024342, 0x00024343, 0x00024442, 0x00024443, 0x00024444, 0x00024543, 0x00024544, 0x00024545, 0x00024644, 0x00024645, 0x00024646, 0x00024745, 0x00024746, 0x00024747, 0x00024846, 0x00024847, 0x00024848, 0x00024947, 0x00024948, 0x00024949, 0x00024a48, 0x00024a49, 0x00024a4a, 0x00024b49, 0x00024b4a, 0x00024b4b, 0x00024c4a, 0x00024c4b, 0x00024c4c, 0x00024d4b, 0x00024d4c, 0x00024d4d, 0x00024e4c, 0x00024e4d, 0x00024e4e, 0x00024f4d, 0x00024f4e, 0x00024f4f, 0x0002504e, 0x0002504f, 0x00025050, 0x0002514f, 0x00025150, 0x00025151, 0x00025250, 0x00025251, 0x00025252, 0x00025351, 0x00025352, 0x00025353, 0x00025452, 0x00025453, 0x00025454, 0x00025553, 0x00025554, 0x00025555, 0x00025654, 0x00025655, 0x00025656, 0x00025755, 0x00025756, 0x00025757, 0x00025856, 0x00025857, 0x00025858, 0x00025957, 0x00025958, 0x00025959, 0x00025a58, 0x00025a59, 0x00025a5a, 0x00025b59, 0x00025b5a, 0x00025b5b, 0x00025c5a, 0x00025c5b, 0x00025c5c, 0x00025d5b, 0x00025d5c, 0x00025d5d, 0x00025e5c, 0x00025e5d, 0x00025e5e, 0x00026260, 0x00026261, 0x00026262, 0x00026361, 0x00026362, 0x00026363, 0x00026462, 0x00026463, 0x00026464, 0x00026563, 0x00026564, 0x00026565, 0x00026664, 0x00026665, 0x00026666, 0x00026765, 0x00026766, 0x00026767, 0x00026866, 0x00026867, 0x00026868, 0x00026967, 0x00026968, 0x00026969, 0x00026a68, 0x00026a69, 0x00026a6a, 0x00026b69, 0x00026b6a, 0x00026b6b, 0x00026c6a, 0x00026c6b, 0x00026c6c, 0x00026d6b, 0x00026d6c, 0x00026d6d, 0x00026e6c, 0x00026e6d, 0x00026e6e, 0x00026f6d, 0x00026f6e, 0x00026f6f, 0x0002706e, 0x0002706f, 0x00027070, 0x0002716f, 0x00027170, 0x00027171, 0x00027270, 0x00027271, 0x00027272, 0x00027371, 0x00027372, 0x00027373, 0x00027472, 0x00027473, 0x00027474, 0x00027573, 0x00027574, 0x00027575, 0x00027674, 0x00027675, 0x00027676, 0x00027775, 0x00027776, 0x00027777, 0x00027876, 0x00027877, 0x00027878, 0x00027977, 0x00027978, 0x00027979, 0x00027a78, 0x00027a79, 0x00027a7a, 0x00027b79, 0x00027b7a, 0x00027b7b, 0x00027c7a, 0x00027c7b, 0x00027c7c, 0x00027d7b, 0x00027d7c, 0x00027d7d, 0x00027e7c, 0x00027e7d, 0x00027e7e, 0x00027f7d, 0x00027f7e, 0x00027f7f, 0x0002807e, 0x0002807f, 0x00028080, 0x0002817f, 0x00028180, 0x00028181, 0x00028280, 0x00028281, 0x00028282, 0x00034645, 0x00043534, 0x00043535, 0x00043635, 0x00043636, 0x00043837, 0x00043838, 0x00043938, 0x00043939, 0x00043a39, 0x00043a3a, 0x00043b3a, 0x00043b3b, 0x00043c3b, 0x00043c3c, 0x00043d3c, 0x00043d3d, 0x00043e3d, 0x00043e3e, 0x00043f3e, 0x00043f3f, 0x0004403f, 0x00044040, 0x00044140, 0x00044141, 0x00044948, 0x00044949, 0x00044a49, 0x00044a4a, 0x00044b4a, 0x00044b4b, 0x00044c4b, 0x00044c4c, 0x00044d4c, 0x00044d4d, 0x00044e4d, 0x00044e4e, 0x00044f4e, 0x00044f4f, 0x0004504f, 0x00045050, 0x00045150, 0x00045151, 0x00045251, 0x00045252, 0x00045352, 0x00045353, 0x00045453, 0x00045454, 0x00045554, 0x00045555, 0x00045655, 0x00045656, 0x00045756, 0x00045757, 0x00045857, 0x00045858, 0x00045958, 0x00045959, 0x00045a59, 0x00045a5a, 0x00045b5a, 0x00045b5b, 0x00045c5b, 0x00045c5c, 0x00045d5c, 0x00045d5d, 0x00045e5d, 0x00045e5e, 0x00045f5e, 0x00045f5f, 0x0004605f, 0x00046060, 0x00046160, 0x00046161, 0x00046261, 0x00046262, 0x00046968, 0x00046969, 0x00046a69, 0x00046a6a, 0x00046b6a, 0x00046b6b, 0x00046c6b, 0x00046c6c, 0x00046d6c, 0x00046d6d, 0x00046e6d, 0x00046e6e, 0x00046f6e, 0x00046f6f, 0x0004706f, 0x00047070, 0x00047170, 0x00047171, 0x00047271, 0x00047272, 0x00047372, 0x00047373, 0x00047473, 0x00047474, 0x00047574, 0x00047575, 0x00047675, 0x00047676, 0x00047776, 0x00047777, 0x00047877, 0x00047878, 0x00047978, 0x00047979, 0x00047a79, 0x00047a7a, 0x00047b7a, 0x00047b7b, 0x00047c7b, 0x00047c7c, 0x00047d7c, 0x00047d7d, 0x00047e7d, 0x00047e7e, 0x00047f7e, 0x00047f7f, 0x0004807f, 0x00048080, 0x00048180, 0x00048181, 0x00048281, 0x00048282, 0x00ca91e5],
    values: [0x00000000, 0x00000000, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000000],
    maximum: 0x00ca91e5
};

pub global CAPTURE_1_MAX_LENGTH: u32 = 320;
pub global NUM_CAPTURE_GROUPS: u32 = 1;

/**
 * Constrains a start state to be valid
 * @dev start states are hardcoded in this function - "(start_state - {state})" for each start
 *      example: `(start_state - 0) * (start_state - 1) * (start_state - 2)` means 0, 1, or 2
 *      are valid first states
 * 
 * @param start_state - The start state of the NFA
 */
fn check_start_state(start_state: Field) {
    let valid_start_state = (start_state - 0) * (start_state - 1);
    assert(valid_start_state == 0, "Invalid start state");
}
    
/**
 * Constrains the recognition of accept_state being reached. If an aceppt state is reached,
 *      ensures asserted traversal path is valid
 * @dev accept states are hardcoded in this function - "(next_state - {state})" for each accept
 *      example: `(next_state - 19) * (next_state - 20) * (next_state - 21)` means 19, 20, or 21
 *      are valid accept states
 * 
 * @param next_state - The asserted next state of the NFA
 * @param haystack_index - The index being operated on in the haystack
 * @param asserted_match_length - The asserted traversal path length
 * @return - 0 if accept_state is reached, nonzero otherwise
 */
fn check_accept_state(
    next_state: Field,
    haystack_index: Field, 
    asserted_match_length: Field
) -> Field {
    // check if the next state is an accept state
    let accept_state_reached = (next_state - 4);
    let accept_state_reached_bool = (accept_state_reached == 0) as Field;

    // check if the haystack index is the asserted match length
    // should equal 1 since haystack_index should be 1 less than asserted_match)length
    let asserted_path_traversed = (asserted_match_length - haystack_index == 1) as Field;

    // if accept state reached, check asserted path traversed. Else return 1
    let valid_condition =
        (1 - accept_state_reached_bool) + (accept_state_reached_bool * asserted_path_traversed);
    assert(valid_condition == 1, "Accept state reached but not at asserted path end");

    // return accept_state reached value
    accept_state_reached
}

pub fn regex_match<let MAX_HAYSTACK_LEN: u32, let MAX_MATCH_LEN: u32>(
    in_haystack: [u8; MAX_HAYSTACK_LEN],
    match_start: u32,
    match_length: u32,
    current_states: [Field; MAX_MATCH_LEN],
    next_states: [Field; MAX_MATCH_LEN],
    capture_group_ids: [Field; MAX_MATCH_LEN],
    capture_group_starts: [Field; MAX_MATCH_LEN],
    capture_group_start_indices: [Field; NUM_CAPTURE_GROUPS],
) -> (BoundedVec<u8, CAPTURE_1_MAX_LENGTH>) {
    // regex:"([A-Za-z0-9!#$%&'*+=?\\-\\^_`{|}~./@]+@[A-Za-z0-9.\\-]+)"
    // resize haystack 
    let haystack: [u8; MAX_MATCH_LEN] = select_subarray(in_haystack, match_start, match_length);

    let mut reached_end_state = 1;
    check_start_state(current_states[0]);
    for i in 0..MAX_MATCH_LEN-1 {
        // match length - 1 since current states should be 1 less than next states
        let in_range = (i < match_length - 1) as Field;
        let matching_states = current_states[i + 1] - next_states[i];
        assert(in_range * matching_states == 0, "Invalid Transition Input");
    }
    for i in 0..MAX_MATCH_LEN {
        check_transition_with_captures(
            TRANSITION_TABLE,
            haystack[i] as Field,
            current_states[i],
            next_states[i],
            capture_group_ids[i],
            capture_group_starts[i],
            reached_end_state
        );
        reached_end_state = reached_end_state * check_accept_state(
            next_states[i],
            i as Field,
            match_length as Field,
        );
    }
    assert(reached_end_state == 0, "Did not reach a valid end state");
     // Capture Group 1
     let capture_1 = capture_substring::<MAX_MATCH_LEN, CAPTURE_1_MAX_LENGTH, 1>(
        haystack,
        capture_group_ids,
        capture_group_starts,
        capture_group_start_indices[0],
     );
    (capture_1)
}

